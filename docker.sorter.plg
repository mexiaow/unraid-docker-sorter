<?xml version="1.0" standalone="yes"?>
<!DOCTYPE PLUGIN [
  <!ENTITY name "docker.sorter">
  <!ENTITY author "mexiaow">
  <!ENTITY github "mexiaow/unraid-docker-sorter">
  <!ENTITY launch "Tools/Docker Sorter">
  <!ENTITY plugdir "/usr/local/emhttp/plugins/&name;">
  <!ENTITY version "2026.01.12">
  <!ENTITY pluginURL "https://raw.githubusercontent.com/&github;/main/&name;.plg">
  <!ENTITY plugin "/boot/config/plugins/&name;">
  <!ENTITY emhttp "&plugdir;">
]>

<PLUGIN name="&name;" author="&author;" version="&version;" launch="&launch;" pluginURL="&pluginURL;" icon="sort-amount-down" min="7.2.3" support="https://github.com/&github;">

<CHANGES>
###2026.01.12
- 修复：插件更新报 “xml parse error”（`CHANGES` 文本里的 `&lt;FILE&gt;` 已转义，避免 XML 解析失败）
- 修复：更新插件时强制重写 Tools 页面文件（将关键 `&lt;FILE&gt;` 标记为 `Method="install"`，避免只更新 U 盘 `.plg` 但 `/usr/local/...` 仍是旧版）

###0.1.20
- 新增：导出/导入顺序（导出为本地 JSON 文件；导入支持 JSON 与 userprefs.cfg 文本）

###0.1.19
- 优化：顶部改为三行布局（按钮/列数在第1行，信息在第2行，搜索在第3行且更短）

###0.1.18
- 优化：顶部布局（搜索左侧，列数+按钮右侧同一行）
- 增强：列数范围改为 6~15，默认 8
- 调整：`pluginURL` 改回旧格式（不带版本参数）

###0.1.17
- 优化：顶部工具栏重新布局（列数/搜索/按钮更紧凑，调试信息可折叠）

###0.1.16
- 修复：`pluginURL` 自动带版本参数（避免 Raw 缓存导致升级后仍加载旧页面/旧 JS）

###0.1.15
- 修复：更新源改为 `raw.githubusercontent.com/.../main/...`（避免 `refs/heads/main` 缓存导致“更新后 Tools 仍是旧版本”）

###0.1.14
- 修复：Unraid CSRF 校验不读取 JSON body，保存/备份改为 `application/x-www-form-urlencoded`（token 进入 `$_POST`），避免仍报 missing

###0.1.13
- 修复：`csrf_token` 获取更稳（优先读取页面全局变量/隐藏字段，并在后端从 `/var/local/emhttp/var.ini` 兜底）

###0.1.12
- 修复：Unraid webGUI 对 POST 强制 CSRF，`backup/saveOrder` 现在会自动携带 `csrf_token`（避免空响应与日志报错）

###0.1.11
- 修复：插件 XML 解析失败导致“安装后页面消失”（`CHANGES` 里误写了 `&lt;name&gt;` 触发 XML 标签解析）

###0.1.10
- 修复：`saveOrder` 在 `json_encode` 失败时不再返回空响应（输出明确错误 JSON）
- 修复：图标优先复用 DockerMan 缓存的 `/state/.../NAME-icon.*`（仅在缓存不存在时才回退到问号图标，避免 404 刷屏）

###0.1.9
- 修复：图标回退与 Docker 页一致（无图标直接用 /plugins/dynamix.docker.manager/images/question.png）
- 修复：不再尝试 NAME-icon.png，避免大量 404 导致频闪与刷屏

###0.1.8
- 修复：saveOrder 返回空响应时给出明确错误（并在后端致命错误时强制返回 JSON）

###0.1.7
- 修复：保存顺序改为插件后端直接写入 dockerMan user-prefs（不再依赖直接 POST UserPrefs.php）
- 修复：写入校验按索引排序并过滤 folder-*，避免误判
- 优化：占位图标使用 data URI，避免任何 404 刷屏

###0.1.6
- 增强：在页面显示顺序来源与 user-prefs 路径/时间戳，保存后自动校验是否写入生效
- 修复：缺省图标与远程图标回退导致的频闪/刷屏（跳过 http(s) 图标，不再依赖 /webGui/images/question.png）

###0.1.5
- 修复：api.php 发生 PHP 致命错误时仍返回 JSON（避免前端出现 “Unexpected end of JSON input”）

###0.1.4
- 修复：备份接口返回非 JSON 时不阻断保存（并输出更清晰错误信息）
- 修复：前端 API 响应解析更健壮（避免 “Unexpected end of JSON input” 直接中断）

###0.1.3
- 修复：保存/回滚不再强制要求 csrf_token（UserPrefs.php 实际不校验）
- 修复：静态资源增加 cache-bust，避免浏览器继续用旧版 JS/CSS 导致 404 刷屏

###0.1.2
- 修复：csrf_token 获取更稳（cookie / api / Report.php 多重回退）
- 修复：缺省图标不再 404 闪烁刷屏（改用插件内置占位图标）

###0.1.1
- 修复：自动获取 csrf_token（含 Report.php 回退）
- 修复：按 DockerMan 实际顺序初始化（过滤 folder-*）
- 修复：图标优先使用 /state/plugins/dynamix.docker.manager/images/NAME-icon.png

###0.1.0
- 初版：网格拖拽排序 + 保存到 Docker 页顺序（复用 UserPrefs.php）
</CHANGES>

<!-- Post-install: create persistent config dirs -->
<FILE Run="/bin/bash" Method="install">
<INLINE>
mkdir -p "&plugin;/backups"
mkdir -p "&emhttp;/images" "&emhttp;/css" "&emhttp;/js" "&emhttp;/include"
</INLINE>
</FILE>

<FILE Name="&emhttp;/DockerSorter.page" Mode="0644" Method="install">
<INLINE><![CDATA[
Icon="docker-sorter.svg"
Menu="Tools"
Title="Docker Sorter"
---
<?php
  header('Cache-Control: no-store, no-cache, must-revalidate, max-age=0');
  header('Pragma: no-cache');
  $token = $csrf_token ?? ($_SESSION['csrf_token'] ?? '');
  $css_v = @filemtime('/usr/local/emhttp/plugins/docker.sorter/css/docker-sorter.css') ?: time();
  $js_v  = @filemtime('/usr/local/emhttp/plugins/docker.sorter/js/docker-sorter.js') ?: time();
?>
<link rel="stylesheet" href="/plugins/docker.sorter/css/docker-sorter.css?v=<?=$css_v?>">

<div id="docker-sorter-root" class="ds-root">
  <div class="ds-toolbar">
    <div class="ds-toolbar-left">
      <div class="ds-title">Docker Sorter</div>
      <div class="ds-subtitle">网格拖拽排序，保存后同步到 Docker 页面（v2026.01.12）</div>
    </div>
    <div class="ds-toolbar-right">
      <label class="ds-label">
        <span>每行列数</span>
        <input id="ds-columns" type="range" min="6" max="15" step="1" value="8" />
        <span id="ds-columns-value" class="ds-mono">8</span>
      </label>
      <div class="ds-actions">
        <button id="ds-reload" class="ds-btn">刷新</button>
        <button id="ds-export" class="ds-btn">导出</button>
        <button id="ds-import" class="ds-btn">导入</button>
        <button id="ds-rollback" class="ds-btn ds-btn-secondary">回滚上次</button>
        <button id="ds-save" class="ds-btn ds-btn-primary">保存到 Docker 页</button>
      </div>
    </div>
  </div>

  <div id="ds-message" class="ds-message" style="display:none;"></div>
  <details id="ds-debug-details" class="ds-debug-details" style="display:none;">
    <summary id="ds-debug-summary">详情</summary>
    <pre id="ds-debug" class="ds-debug"></pre>
  </details>

  <div class="ds-search-row">
    <input id="ds-search" class="ds-search" type="text" placeholder="搜索（命中高亮，其他变暗）" />
  </div>

  <input id="ds-import-file" type="file" accept=".json,.cfg,.txt" style="display:none;" />

  <div id="ds-grid" class="ds-grid" style="--ds-cols: 6;"></div>
</div>

<script>
  window.DockerSorter = {
    apiBase: "/plugins/docker.sorter/include/api.php",
    saveEndpoint: "/plugins/dynamix.docker.manager/include/UserPrefs.php",
    csrfToken: "<?=htmlspecialchars($token, ENT_QUOTES)?>",
    reportConfigUrl: "/webGui/include/Report.php?cmd=config",
    build: "2026.01.12"
  };
</script>

<!-- SortableJS: CDN 加载（触屏/网格拖拽体验更好）。 -->
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
<script src="/plugins/docker.sorter/js/docker-sorter.js?v=<?=$js_v?>"></script>
]]></INLINE>
</FILE>

<FILE Name="&emhttp;/docker-sorter.svg" Mode="0644" Method="install">
<INLINE><![CDATA[
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  <defs>
    <linearGradient id="g" x1="0" x2="1" y1="0" y2="1">
      <stop offset="0" stop-color="#4f8cff"/>
      <stop offset="1" stop-color="#00d084"/>
    </linearGradient>
  </defs>
  <rect x="6" y="10" width="52" height="44" rx="10" fill="#1f2937"/>
  <g fill="url(#g)">
    <rect x="16" y="20" width="14" height="10" rx="3"/>
    <rect x="34" y="20" width="14" height="10" rx="3"/>
    <rect x="16" y="34" width="14" height="10" rx="3"/>
    <rect x="34" y="34" width="14" height="10" rx="3"/>
  </g>
  <circle cx="50" cy="16" r="4" fill="#22c55e"/>
  <path d="M13 48h38" stroke="#94a3b8" stroke-width="3" stroke-linecap="round"/>
</svg>
]]></INLINE>
</FILE>

<FILE Name="&emhttp;/css/docker-sorter.css" Mode="0644" Method="install">
<INLINE><![CDATA[
.ds-root {
  padding: 14px 10px 10px;
}

.ds-toolbar {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  flex-wrap: wrap;
  align-items: flex-start;
  margin-bottom: 12px;
}

.ds-toolbar-left {
  min-width: 220px;
  padding-top: 2px;
}

.ds-title {
  font-size: 16px;
  font-weight: 700;
}

.ds-subtitle {
  font-size: 12px;
  opacity: 0.75;
}

.ds-toolbar-right {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  align-items: center;
  justify-content: flex-end;
}

.ds-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
  justify-content: flex-end;
}

.ds-search-row {
  margin: 0 0 12px;
}

.ds-label {
  display: inline-flex;
  gap: 8px;
  align-items: center;
  padding: 6px 10px;
  border: 1px solid rgba(148, 163, 184, 0.35);
  border-radius: 10px;
}

.ds-mono {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

.ds-search {
  width: clamp(220px, 30vw, 420px);
  max-width: 100%;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid rgba(148, 163, 184, 0.35);
  background: rgba(15, 23, 42, 0.25);
}

.ds-btn {
  padding: 8px 12px;
  border-radius: 10px;
  border: 1px solid rgba(148, 163, 184, 0.35);
  background: rgba(15, 23, 42, 0.25);
  cursor: pointer;
}

.ds-btn:hover {
  background: rgba(15, 23, 42, 0.4);
}

.ds-btn-primary {
  border-color: rgba(34, 197, 94, 0.55);
}

.ds-btn-secondary {
  border-color: rgba(59, 130, 246, 0.55);
}

.ds-message {
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid rgba(148, 163, 184, 0.35);
  background: rgba(15, 23, 42, 0.25);
  margin: 8px 0 12px;
}

.ds-debug-details {
  border-radius: 10px;
  border: 1px solid rgba(148, 163, 184, 0.35);
  background: rgba(15, 23, 42, 0.25);
  margin: 0 0 12px;
}

.ds-debug-details > summary {
  padding: 10px 12px;
  cursor: pointer;
  user-select: none;
  font-size: 12px;
  opacity: 0.9;
}

.ds-debug-details[open] > summary {
  border-bottom: 1px solid rgba(148, 163, 184, 0.18);
}

.ds-debug {
  margin: 0;
  padding: 10px 12px;
  white-space: pre-wrap;
  font-size: 12px;
  opacity: 0.9;
}

.ds-grid {
  --ds-cols: 6;
  display: grid;
  grid-template-columns: repeat(var(--ds-cols), minmax(110px, 1fr));
  gap: 10px;
}

.ds-card {
  user-select: none;
  border-radius: 14px;
  border: 1px solid rgba(148, 163, 184, 0.35);
  background: rgba(2, 6, 23, 0.35);
  padding: 10px 10px 8px;
  display: grid;
  grid-template-columns: 42px 1fr;
  grid-template-rows: auto auto;
  column-gap: 10px;
  row-gap: 4px;
}

.ds-card-wrap.ds-dim .ds-card {
  opacity: 0.25;
}

.ds-card-wrap.ds-match .ds-card {
  outline: 2px solid rgba(59, 130, 246, 0.8);
  outline-offset: 2px;
}

.ds-card-wrap.ds-chosen .ds-card {
  outline: 2px solid rgba(34, 197, 94, 0.75);
  outline-offset: 2px;
}

.ds-card .ds-icon {
  width: 42px;
  height: 42px;
  border-radius: 10px;
  background: rgba(148, 163, 184, 0.12);
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}

.ds-card .ds-icon img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.ds-card .ds-name {
  font-size: 12px;
  font-weight: 700;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.ds-card .ds-meta {
  font-size: 11px;
  opacity: 0.8;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

.ds-dot {
  width: 8px;
  height: 8px;
  border-radius: 999px;
  display: inline-block;
}
.ds-dot.running { background: #22c55e; }
.ds-dot.stopped { background: #ef4444; }

.ds-index {
  position: absolute;
  top: 6px;
  left: 8px;
  font-size: 10px;
  opacity: 0.65;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

.ds-card-wrap {
  position: relative;
}
]]></INLINE>
</FILE>

<FILE Name="&emhttp;/js/docker-sorter.js" Mode="0644" Method="install">
<INLINE><![CDATA[
(function () {
  "use strict";

  const apiBase = window.DockerSorter?.apiBase;
  const saveEndpoint = window.DockerSorter?.saveEndpoint;
  let csrfToken = window.DockerSorter?.csrfToken || "";
  const reportConfigUrl = window.DockerSorter?.reportConfigUrl;
  const placeholderIcon = "/plugins/dynamix.docker.manager/images/question.png";

  const gridEl = document.getElementById("ds-grid");
  const messageEl = document.getElementById("ds-message");
  const debugEl = document.getElementById("ds-debug");
  const debugDetailsEl = document.getElementById("ds-debug-details");
  const debugSummaryEl = document.getElementById("ds-debug-summary");
  const columnsEl = document.getElementById("ds-columns");
  const columnsValueEl = document.getElementById("ds-columns-value");
  const searchEl = document.getElementById("ds-search");
  const reloadEl = document.getElementById("ds-reload");
  const exportEl = document.getElementById("ds-export");
  const importEl = document.getElementById("ds-import");
  const importFileEl = document.getElementById("ds-import-file");
  const saveEl = document.getElementById("ds-save");
  const rollbackEl = document.getElementById("ds-rollback");

  let containersByName = new Map();
  let lastSavedOrder = [];
  let currentColumns = 8;
  let sortable = null;

  function showMessage(text, type) {
    messageEl.style.display = "block";
    messageEl.textContent = text;
    messageEl.style.borderColor =
      type === "error"
        ? "rgba(239, 68, 68, 0.6)"
        : type === "ok"
          ? "rgba(34, 197, 94, 0.6)"
          : "rgba(148, 163, 184, 0.35)";
  }

  function clearMessage() {
    messageEl.style.display = "none";
    messageEl.textContent = "";
  }

  function setDebug(text) {
    if (!debugEl || !debugDetailsEl) return;
    if (!text) {
      debugDetailsEl.style.display = "none";
      debugDetailsEl.open = false;
      debugEl.textContent = "";
      if (debugSummaryEl) debugSummaryEl.textContent = "详情";
      return;
    }
    debugDetailsEl.style.display = "block";
    debugEl.textContent = text;
    const firstLine = String(text).split(/\r?\n/)[0]?.trim() || "";
    if (debugSummaryEl) debugSummaryEl.textContent = firstLine || "详情";
  }

  function clampColumns(value) {
    const numberValue = Number(value);
    if (!Number.isFinite(numberValue)) return 8;
    return Math.min(15, Math.max(6, numberValue));
  }

  async function apiGet(action) {
    const response = await fetch(`${apiBase}?action=${encodeURIComponent(action)}`, {
      credentials: "same-origin",
      headers: { "Accept": "application/json" },
    });
    const text = await response.text();
    if (!response.ok) throw new Error(text || `HTTP ${response.status}`);
    if (!text) throw new Error(`API 返回空响应：${action}`);
    try {
      return JSON.parse(text);
    } catch (e) {
      throw new Error(`API 返回非 JSON：${String(e?.message || e)}\n${text.slice(0, 300)}`);
    }
  }

  async function apiPost(action, payload) {
    const token = await ensureCsrfToken();
    if (!token) throw new Error("缺少 csrf_token（可能是登录状态异常）。请刷新页面后重试。");
    const url = `${apiBase}?action=${encodeURIComponent(action)}`;
    const form = new URLSearchParams();
    form.set("csrf_token", token);
    const body = payload || {};
    for (const [k, v] of Object.entries(body)) {
      if (k === "csrf_token") continue;
      if (Array.isArray(v) || (v && typeof v === "object")) {
        form.set(k, JSON.stringify(v));
      } else if (typeof v !== "undefined") {
        form.set(k, String(v));
      }
    }
    const response = await fetch(url, {
      method: "POST",
      credentials: "same-origin",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "Accept": "application/json",
        "X-CSRF-Token": token,
        "X-Requested-With": "XMLHttpRequest",
      },
      body: form.toString(),
    });
    const text = await response.text();
    if (!response.ok) throw new Error(text || `HTTP ${response.status}`);
    if (!text) throw new Error(`API 返回空响应：${action}`);
    try {
      return JSON.parse(text);
    } catch (e) {
      throw new Error(`API 返回非 JSON：${String(e?.message || e)}\n${text.slice(0, 300)}`);
    }
  }

  async function ensureCsrfToken() {
    if (csrfToken) return csrfToken;

    const globalCandidates = [
      window.csrf_token,
      window.csrfToken,
      window.CSRF_TOKEN,
      window.top?.csrf_token,
      window.parent?.csrf_token,
    ];
    for (const cand of globalCandidates) {
      if (typeof cand === "string" && cand.trim()) {
        csrfToken = cand.trim().toUpperCase();
        return csrfToken;
      }
    }

    const inputEl = document.querySelector('input[name="csrf_token"][value]');
    if (inputEl && typeof inputEl.value === "string" && inputEl.value.trim()) {
      csrfToken = inputEl.value.trim().toUpperCase();
      return csrfToken;
    }

    const metaEl =
      document.querySelector('meta[name="csrf_token"][content]') ||
      document.querySelector('meta[name="csrf-token"][content]');
    if (metaEl && typeof metaEl.content === "string" && metaEl.content.trim()) {
      csrfToken = metaEl.content.trim().toUpperCase();
      return csrfToken;
    }

    const cookieMatch = document.cookie.match(/(?:^|;\s*)csrf_token=([^;]+)/i);
    if (cookieMatch && cookieMatch[1]) {
      csrfToken = decodeURIComponent(cookieMatch[1]).toUpperCase();
      return csrfToken;
    }

    try {
      const data = await apiGet("csrf");
      if (data && typeof data.csrf_token === "string" && data.csrf_token) {
        csrfToken = data.csrf_token;
        return csrfToken;
      }
    } catch (_) {
      // ignore
    }

    if (reportConfigUrl) {
      const response = await fetch(reportConfigUrl, { credentials: "same-origin" });
      const text = await response.text();
      const candidates = [
        /csrf_token=([0-9A-F]+)/i,
        /"csrf_token"\s*:\s*"([0-9A-F]+)"/i,
        /name=["']csrf_token["']\s+value=["']([0-9A-F]+)["']/i,
        /csrf_token&amp;#x3D;([0-9A-F]+)/i,
      ];
      for (const rx of candidates) {
        const m = text.match(rx);
        if (m && m[1]) {
          csrfToken = m[1].toUpperCase();
          return csrfToken;
        }
      }
    }

    return "";
  }

  function buildCard(container, index) {
    const wrapper = document.createElement("div");
    wrapper.className = "ds-card-wrap";
    wrapper.dataset.name = container.name;

    const card = document.createElement("div");
    card.className = "ds-card";

    const indexEl = document.createElement("div");
    indexEl.className = "ds-index";
    indexEl.textContent = String(index + 1).padStart(2, "0");

    const iconEl = document.createElement("div");
    iconEl.className = "ds-icon";
    const imgEl = document.createElement("img");
    imgEl.alt = container.name;
    imgEl.loading = "lazy";
    imgEl.decoding = "async";
    imgEl.src = container.icon || placeholderIcon;
    imgEl.addEventListener(
      "error",
      () => {
        if (imgEl.src !== placeholderIcon) imgEl.src = placeholderIcon;
        imgEl.onerror = null;
      },
      { once: true }
    );
    iconEl.appendChild(imgEl);

    const nameEl = document.createElement("div");
    nameEl.className = "ds-name";
    nameEl.textContent = container.name;

    const metaEl = document.createElement("div");
    metaEl.className = "ds-meta";
    const dotEl = document.createElement("span");
    dotEl.className = `ds-dot ${container.running ? "running" : "stopped"}`;
    const statusTextEl = document.createElement("span");
    statusTextEl.textContent = container.running ? "已启动" : "已停止";
    metaEl.appendChild(dotEl);
    metaEl.appendChild(statusTextEl);

    card.appendChild(iconEl);
    card.appendChild(nameEl);
    card.appendChild(document.createElement("div"));
    card.appendChild(metaEl);

    wrapper.appendChild(indexEl);
    wrapper.appendChild(card);
    return wrapper;
  }

  function getOrderFromGrid() {
    return Array.from(gridEl.querySelectorAll(".ds-card-wrap")).map((el) => el.dataset.name);
  }

  function normalizeImportedOrder(order) {
    if (!Array.isArray(order)) return [];
    const out = [];
    const seen = new Set();
    for (const raw of order) {
      const name = String(raw || "").trim();
      if (!name) continue;
      if (name.startsWith("folder-")) continue;
      if (seen.has(name)) continue;
      seen.add(name);
      out.push(name);
    }
    return out;
  }

  function parseOrderFromText(text) {
    const rawText = String(text || "");
    const trimmed = rawText.trim();
    if (!trimmed) return [];

    // JSON: { order: [...] } or [ ... ]
    if (trimmed.startsWith("{") || trimmed.startsWith("[")) {
      try {
        const json = JSON.parse(trimmed);
        if (Array.isArray(json)) return normalizeImportedOrder(json);
        if (json && Array.isArray(json.order)) return normalizeImportedOrder(json.order);
      } catch (_) {
        // fall through
      }
    }

    // dockerMan userprefs.cfg lines: 0="name"
    const cfgMatches = [];
    const cfgRx = /^\s*\d+\s*=\s*"([^"]*)"/gm;
    let m;
    while ((m = cfgRx.exec(rawText))) {
      if (m[1]) cfgMatches.push(m[1]);
    }
    if (cfgMatches.length > 0) return normalizeImportedOrder(cfgMatches);

    // Form dump: names: a;b;c;
    const namesLine = rawText.match(/^\s*names:\s*([^\r\n]+)\s*$/im);
    if (namesLine && namesLine[1]) {
      const names = namesLine[1]
        .split(";")
        .map((s) => s.trim())
        .filter(Boolean);
      if (names.length > 0) return normalizeImportedOrder(names);
    }

    // Fallback: split by newline / comma / semicolon
    const parts = rawText
      .split(/[\r\n,;]+/)
      .map((s) => s.trim())
      .filter(Boolean);
    return normalizeImportedOrder(parts);
  }

  function downloadText(filename, content, mime) {
    const blob = new Blob([content], { type: mime || "application/octet-stream" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }

  function formatTimestampForFilename(date) {
    const d = date instanceof Date ? date : new Date();
    const pad2 = (n) => String(n).padStart(2, "0");
    return `${d.getFullYear()}${pad2(d.getMonth() + 1)}${pad2(d.getDate())}-${pad2(d.getHours())}${pad2(d.getMinutes())}${pad2(d.getSeconds())}`;
  }

  function doExport() {
    const order = getOrderFromGrid();
    const payload = {
      schema: 1,
      exportedAt: new Date().toISOString(),
      columns: currentColumns,
      order,
    };
    const filename = `docker-sorter-order-${formatTimestampForFilename(new Date())}.json`;
    downloadText(filename, JSON.stringify(payload, null, 2), "application/json; charset=utf-8");
    showMessage("已导出到本地文件。", "ok");
  }

  async function doImportFromFile(file) {
    if (!file) return;
    const text = await file.text();
    const parsed = parseOrderFromText(text);
    if (!parsed || parsed.length === 0) {
      showMessage("导入失败：文件里没有识别到顺序（支持 JSON 或 userprefs.cfg 格式）。", "error");
      return;
    }
    if (containersByName.size === 0) {
      await loadState();
    }
    render(parsed);
    updateIndices();
    showMessage("已导入。请检查顺序后点击“保存到 Docker 页”。", "ok");
  }

  function render(order) {
    gridEl.innerHTML = "";
    const finalOrder = order.filter((name) => containersByName.has(name));
    const missing = Array.from(containersByName.keys()).filter((name) => !finalOrder.includes(name));
    finalOrder.push(...missing);

    finalOrder.forEach((name, index) => {
      const container = containersByName.get(name);
      if (!container) return;
      gridEl.appendChild(buildCard(container, index));
    });

    applySearch(searchEl.value || "");
    enableDrag();
  }

  function updateIndices() {
    const cards = Array.from(gridEl.querySelectorAll(".ds-card-wrap"));
    cards.forEach((cardEl, index) => {
      const indexEl = cardEl.querySelector(".ds-index");
      if (indexEl) indexEl.textContent = String(index + 1).padStart(2, "0");
    });
  }

  function applyColumns(columns) {
    currentColumns = clampColumns(columns);
    columnsEl.value = String(currentColumns);
    columnsValueEl.textContent = String(currentColumns);
    gridEl.style.setProperty("--ds-cols", String(currentColumns));
  }

  function applySearch(query) {
    const q = String(query || "").trim().toLowerCase();
    const cards = Array.from(gridEl.querySelectorAll(".ds-card-wrap"));
    cards.forEach((el) => {
      const name = (el.dataset.name || "").toLowerCase();
      const match = q.length === 0 ? true : name.includes(q);
      el.classList.toggle("ds-dim", q.length > 0 && !match);
      el.classList.toggle("ds-match", q.length > 0 && match);
    });
  }

  function enableDrag() {
    if (sortable) {
      sortable.destroy();
      sortable = null;
    }
    if (!window.Sortable) {
      showMessage("拖拽库未加载（SortableJS）。请检查网络或稍后重试。", "error");
      return;
    }
    sortable = new window.Sortable(gridEl, {
      animation: 150,
      draggable: ".ds-card-wrap",
      ghostClass: "ds-chosen",
      onEnd: function () {
        updateIndices();
      },
    });
  }

  async function loadState() {
    clearMessage();
    setDebug("");
    showMessage("加载中…", "info");
    const state = await apiGet("state");
    containersByName = new Map(state.containers.map((c) => [c.name, c]));
    lastSavedOrder = Array.isArray(state.order) ? state.order : [];
    applyColumns(state.settings?.columns ?? 6);
    render(lastSavedOrder);
    const meta = state.meta || {};
    if (meta.userPrefsPath) {
      const mtime = meta.userPrefsMtime ? new Date(meta.userPrefsMtime * 1000).toLocaleString() : "unknown";
      setDebug(`顺序来源：${meta.orderSource || "unknown"}\nuser-prefs：${meta.userPrefsPath}\nmtime：${mtime}`);
    }
    showMessage("已加载。拖拽后点击“保存到 Docker 页”。", "ok");
  }

  async function saveSettings() {
    try {
      await apiPost("settings", { columns: currentColumns });
    } catch (e) {
      showMessage(`保存设置失败：${e.message || e}`, "error");
    }
  }

  async function doSave() {
    clearMessage();
    const newOrder = getOrderFromGrid();
    try {
      await apiPost("backup", { order: lastSavedOrder });
    } catch (e) {
      showMessage(`备份失败（不影响保存）：${e.message || e}`, "error");
    }

    showMessage("保存中…", "info");
    let saveResult;
    try {
      saveResult = await apiPost("saveOrder", { order: newOrder });
    } catch (e) {
      showMessage(`保存失败：${e.message || e}`, "error");
      return;
    }
    if (!saveResult || saveResult.ok !== true) {
      showMessage(`保存失败：${saveResult?.error || "unknown"}`, "error");
      return;
    }

    lastSavedOrder = newOrder;
    const verify = saveResult.verify || {};
    const same = verify.same === true;
    const mtime = verify.mtime ? new Date(verify.mtime * 1000).toLocaleString() : "unknown";
    setDebug(`user-prefs：${verify.path || "unknown"}\nmtime：${mtime}\n写入校验：${same ? "OK" : "不一致"}`);
    showMessage(same ? "已保存。刷新 Docker 页即可看到新顺序。" : "已保存，但写入校验不一致（见下方调试信息）。", same ? "ok" : "error");
  }

  async function doRollback() {
    clearMessage();
    try {
      const data = await apiGet("latestBackup");
      const order = Array.isArray(data.order) ? data.order : null;
      if (!order || order.length === 0) {
        showMessage("没有可回滚的备份。", "info");
        return;
      }

      showMessage("回滚中…", "info");
      const saveResult = await apiPost("saveOrder", { order });
      if (!saveResult || saveResult.ok !== true) {
        showMessage(`回滚失败：${saveResult?.error || "unknown"}`, "error");
        return;
      }

      lastSavedOrder = order;
      render(order);
      const verify = saveResult.verify || {};
      const same = verify.same === true;
      const mtime = verify.mtime ? new Date(verify.mtime * 1000).toLocaleString() : "unknown";
      setDebug(`user-prefs：${verify.path || "unknown"}\nmtime：${mtime}\n写入校验：${same ? "OK" : "不一致"}`);
      showMessage(same ? "已回滚。刷新 Docker 页即可看到回滚后的顺序。" : "已回滚，但写入校验不一致（见下方调试信息）。", same ? "ok" : "error");
    } catch (e) {
      showMessage(`回滚失败：${e.message || e}`, "error");
    }
  }

  columnsEl.addEventListener("input", () => {
    applyColumns(columnsEl.value);
  });
  columnsEl.addEventListener("change", () => {
    saveSettings();
  });
  searchEl.addEventListener("input", () => {
    applySearch(searchEl.value || "");
  });
  reloadEl.addEventListener("click", () => {
    loadState().catch((e) => showMessage(`加载失败：${e.message || e}`, "error"));
  });
  saveEl.addEventListener("click", () => {
    doSave().catch((e) => showMessage(`保存失败：${e.message || e}`, "error"));
  });
  rollbackEl.addEventListener("click", () => {
    doRollback().catch((e) => showMessage(`回滚失败：${e.message || e}`, "error"));
  });

  exportEl?.addEventListener("click", () => {
    clearMessage();
    try {
      doExport();
    } catch (e) {
      showMessage(`导出失败：${e?.message || e}`, "error");
    }
  });

  importEl?.addEventListener("click", () => {
    clearMessage();
    if (!importFileEl) {
      showMessage("导入不可用：缺少文件选择控件。", "error");
      return;
    }
    importFileEl.value = "";
    importFileEl.click();
  });

  importFileEl?.addEventListener("change", () => {
    const file = importFileEl.files && importFileEl.files[0] ? importFileEl.files[0] : null;
    if (!file) return;
    doImportFromFile(file).catch((e) => showMessage(`导入失败：${e?.message || e}`, "error"));
  });

  loadState().catch((e) => showMessage(`加载失败：${e.message || e}`, "error"));
})();
]]></INLINE>
</FILE>

<FILE Name="&emhttp;/include/api.php" Mode="0644" Method="install">
<INLINE><![CDATA[
<?php
declare(strict_types=1);

header('Content-Type: application/json; charset=utf-8');
header('Cache-Control: no-store, no-cache, must-revalidate, max-age=0');

@session_start();
@ob_start();

ini_set('display_errors', '0');
error_reporting(E_ALL);

function fatal_json_shutdown(): void {
  $err = error_get_last();
  if (!$err) return;
  $fatalTypes = [E_ERROR, E_PARSE, E_CORE_ERROR, E_COMPILE_ERROR, E_USER_ERROR];
  if (!in_array($err['type'], $fatalTypes, true)) return;
  while (ob_get_level() > 0) { @ob_end_clean(); }
  http_response_code(500);
  header('Content-Type: application/json; charset=utf-8');
  $payload = json_encode([
    'ok' => false,
    'error' => 'fatal',
    'message' => $err['message'] ?? '',
    'file' => $err['file'] ?? '',
    'line' => $err['line'] ?? 0,
  ], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
  if ($payload === false || $payload === '') {
    $msg = json_last_error_msg();
    $msgJson = json_encode($msg, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
    echo '{"ok":false,"error":"json_encode_failed","message":' . ($msgJson !== false ? $msgJson : '"unknown"') . '}';
    return;
  }
  echo $payload;
}
register_shutdown_function('fatal_json_shutdown');

function json_out($data, int $status = 200): void {
  $payload = json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
  if ($payload === false || $payload === '') {
    http_response_code(500);
    $msg = json_last_error_msg();
    $msgJson = json_encode($msg, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
    echo '{"ok":false,"error":"json_encode_failed","message":' . ($msgJson !== false ? $msgJson : '"unknown"') . '}';
    exit;
  }
  http_response_code($status);
  echo $payload;
  exit;
}

function read_request_body(): array {
  $raw = file_get_contents('php://input');
  $ct = $_SERVER['CONTENT_TYPE'] ?? '';

  if (is_string($ct) && stripos($ct, 'application/json') !== false) {
    if ($raw === false || $raw === '') return [];
    $decoded = json_decode($raw, true);
    return is_array($decoded) ? $decoded : [];
  }

  $data = [];
  foreach (($_POST ?? []) as $k => $v) $data[(string)$k] = $v;

  if (isset($data['order']) && is_string($data['order']) && $data['order'] !== '') {
    $decoded = json_decode($data['order'], true);
    if (is_array($decoded)) $data['order'] = $decoded;
  }

  return $data;
}

function run_cmd_lines(string $cmd): array {
  $out = [];
  $rc = 0;
  @exec($cmd . ' 2>/dev/null', $out, $rc);
  if ($rc !== 0) return [];
  return array_values(array_filter(array_map('trim', $out), fn($l) => $l !== ''));
}

function docker_container_names(): array {
  return run_cmd_lines("docker ps -a --format '{{.Names}}'");
}

function docker_running_set(): array {
  $names = run_cmd_lines("docker ps --format '{{.Names}}'");
  $set = [];
  foreach ($names as $n) $set[$n] = true;
  return $set;
}

function template_icon_map(): array {
  $dirs = [
    '/boot/config/plugins/dockerMan/templates-user',
    '/boot/config/plugins/dockerMan/templates',
  ];

  $map = [];
  foreach ($dirs as $dir) {
    if (!is_dir($dir)) continue;
    foreach (glob($dir . '/*.xml') ?: [] as $file) {
      $xml = @simplexml_load_file($file);
      if (!$xml) continue;
      $name = isset($xml->Name) ? (string)$xml->Name : '';
      $icon = isset($xml->Icon) ? (string)$xml->Icon : '';
      $name = trim($name);
      $icon = trim($icon);
      if ($name === '' || $icon === '') continue;
      $map[$name] = $icon;
    }
  }

  return $map;
}

function normalize_icon_url(string $icon): string {
  $icon = trim($icon);
  if ($icon === '') return '';
  if (preg_match('#^https?://#i', $icon)) return '';
  if (str_starts_with($icon, '/plugins/') || str_starts_with($icon, '/state/')) return $icon;
  if (str_starts_with($icon, 'file://')) $icon = substr($icon, 7);

  $icon = str_replace('/boot/config/plugins/dockerMan/images/', '/plugins/dynamix.docker.manager/images/', $icon);
  $icon = str_replace('/usr/local/emhttp/plugins/dynamix.docker.manager/images/', '/plugins/dynamix.docker.manager/images/', $icon);

  // 只接受绝对路径，避免相对路径导致的 404 与控制台刷屏
  if (!str_starts_with($icon, '/')) return '';
  return $icon;
}

function dockerMan_state_icon_url(string $name): string {
  $name = trim($name);
  if ($name === '') return '';

  $fsDir = '/usr/local/emhttp/state/plugins/dynamix.docker.manager/images';
  $urlDir = '/state/plugins/dynamix.docker.manager/images';
  if (!is_dir($fsDir)) return '';

  $safe = $name; // docker name characters are safe for this path
  $exts = ['png', 'jpg', 'jpeg', 'svg'];
  foreach ($exts as $ext) {
    $fs = $fsDir . '/' . $safe . '-icon.' . $ext;
    if (!is_file($fs)) continue;
    $mtime = @filemtime($fs);
    $qs = is_int($mtime) && $mtime > 0 ? ('?' . $mtime) : '';
    return $urlDir . '/' . $safe . '-icon.' . $ext . $qs;
  }
  return '';
}

function dockerMan_paths(): array {
  $docroot = ($_SERVER['DOCUMENT_ROOT'] ?? '') ?: '/usr/local/emhttp';
  $path = $docroot . '/plugins/dynamix.docker.manager/include/DockerClient.php';
  if (is_file($path)) {
    require_once $path;
  }
  $paths = $GLOBALS['dockerManPaths'] ?? null;
  return is_array($paths) ? $paths : [];
}

function dockerMan_user_prefs_path(): string {
  $paths = dockerMan_paths();
  if (isset($paths['user-prefs']) && is_string($paths['user-prefs']) && $paths['user-prefs'] !== '') {
    return $paths['user-prefs'];
  }
  return '/boot/config/plugins/dockerMan/userprefs.cfg';
}

function parse_userprefs_cfg_entries(string $path): array {
  if (!is_file($path)) return [];
  $lines = @file($path, FILE_IGNORE_NEW_LINES);
  if (!is_array($lines)) return [];
  $entries = [];
  foreach ($lines as $line) {
    if (preg_match('/^\s*(\d+)\s*=\s*"([^"]*)"/', $line, $m) !== 1) continue;
    $entries[] = ['idx' => (int)$m[1], 'name' => (string)$m[2]];
  }
  return $entries;
}

function userprefs_order_sorted(string $path): array {
  $entries = parse_userprefs_cfg_entries($path);
  usort($entries, fn($a, $b) => ($a['idx'] <=> $b['idx']));
  $out = [];
  foreach ($entries as $e) $out[] = $e['name'];
  return $out;
}

function order_from_dockerMan_user_prefs(array $containerNames): array {
  $set = array_fill_keys($containerNames, true);
  $path = dockerMan_user_prefs_path();
  $raw = userprefs_order_sorted($path);

  $order = [];
  foreach ($raw as $name) {
    if ($name === '') continue;
    if (str_starts_with($name, 'folder-')) continue;
    if (!isset($set[$name])) continue;
    if (in_array($name, $order, true)) continue;
    $order[] = $name;
  }

  $missing = array_values(array_filter($containerNames, fn($n) => !in_array($n, $order, true)));
  return array_merge($order, $missing);
}

function csrf_token_value(): string {
  $t = $GLOBALS['csrf_token'] ?? '';
  if (is_string($t) && $t !== '') return $t;
  $t = $_SESSION['csrf_token'] ?? '';
  if (is_string($t) && $t !== '') return $t;
  $t = $_COOKIE['csrf_token'] ?? '';
  if (is_string($t) && $t !== '') return $t;
  $varIni = '/var/local/emhttp/var.ini';
  if (is_file($varIni)) {
    $ini = @parse_ini_file($varIni, false, INI_SCANNER_RAW);
    if (is_array($ini)) {
      $v = $ini['csrf_token'] ?? '';
      if (is_string($v) && $v !== '') return $v;
    }
  }
  return '';
}

function settings_path(): string {
  return '/boot/config/plugins/docker.sorter/settings.json';
}

function load_settings(): array {
  $path = settings_path();
  if (!is_file($path)) return ['columns' => 8];
  $raw = @file_get_contents($path);
  if ($raw === false) return ['columns' => 8];
  $decoded = json_decode($raw, true);
  if (!is_array($decoded)) return ['columns' => 8];
  $columns = isset($decoded['columns']) ? (int)$decoded['columns'] : 8;
  $columns = max(6, min(15, $columns));
  return ['columns' => $columns];
}

function save_settings(array $settings): bool {
  $path = settings_path();
  $dir = dirname($path);
  if (!is_dir($dir)) @mkdir($dir, 0777, true);
  $tmp = $path . '.tmp';
  $payload = json_encode($settings, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
  if ($payload === false) return false;
  if (@file_put_contents($tmp, $payload) === false) return false;
  return @rename($tmp, $path);
}

function backups_dir(): string {
  return '/boot/config/plugins/docker.sorter/backups';
}

function write_latest_backup(array $order): bool {
  $dir = backups_dir();
  if (!is_dir($dir)) @mkdir($dir, 0777, true);

  $payload = [
    'ts' => time(),
    'order' => array_values($order),
  ];

  $json = json_encode($payload, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
  if ($json === false) return false;
  $file = $dir . '/latest.json';
  $tmp = $file . '.tmp';
  if (@file_put_contents($tmp, $json) === false) return false;
  return @rename($tmp, $file);
}

function read_latest_backup(): array {
  $file = backups_dir() . '/latest.json';
  if (!is_file($file)) return [];
  $raw = @file_get_contents($file);
  if ($raw === false) return [];
  $decoded = json_decode($raw, true);
  return is_array($decoded) ? $decoded : [];
}

$action = $_GET['action'] ?? '';

if ($action === 'csrf') {
  json_out([
    'ok' => true,
    'csrf_token' => csrf_token_value(),
  ]);
}

if ($action === 'prefsInfo') {
  $path = dockerMan_user_prefs_path();
  $raw = userprefs_order_sorted($path);
  $filtered = [];
  foreach ($raw as $name) {
    if ($name === '') continue;
    if (str_starts_with($name, 'folder-')) continue;
    $filtered[] = $name;
  }
  json_out([
    'ok' => true,
    'path' => $path,
    'exists' => is_file($path),
    'mtime' => is_file($path) ? @filemtime($path) : null,
    'size' => is_file($path) ? @filesize($path) : null,
    'order' => $filtered,
    'orderRaw' => $raw,
  ]);
}

if ($action === 'saveOrder') {
  $body = read_request_body();
  $order = $body['order'] ?? null;
  if (!is_array($order)) json_out(['ok' => false, 'error' => 'invalid_order'], 400);

  $containerNames = docker_container_names();
  $set = array_fill_keys($containerNames, true);

  $seen = [];
  $saveLines = [];
  $i = 0;
  $normalized = [];
  foreach ($order as $name) {
    $name = (string)$name;
    if ($name === '' || str_starts_with($name, 'folder-')) continue;
    if (!isset($set[$name])) continue;
    if (isset($seen[$name])) continue;
    $seen[$name] = true;
    $normalized[] = $name;
    $saveLines[] = $i . "=\"" . $name . "\"";
    $i++;
  }
  foreach ($containerNames as $name) {
    if (isset($seen[$name])) continue;
    $seen[$name] = true;
    $normalized[] = $name;
    $saveLines[] = $i . "=\"" . $name . "\"";
    $i++;
  }

  $path = dockerMan_user_prefs_path();
  $dir = dirname($path);
  if (!is_dir($dir)) @mkdir($dir, 0777, true);
  $payload = implode("\n", $saveLines) . "\n";
  $ok = @file_put_contents($path, $payload);
  if ($ok === false) json_out(['ok' => false, 'error' => 'write_failed', 'path' => $path], 500);

  // keep autostart order in sync (same as UserPrefs.php)
  $paths = dockerMan_paths();
  $autostart = $paths['autostart-file'] ?? '';
  if (is_string($autostart) && $autostart !== '' && file_exists($autostart)) {
    $nameToIdx = [];
    foreach ($saveLines as $line) {
      if (preg_match('/^(\d+)="([^"]+)"$/', $line, $m) === 1) {
        $nameToIdx[$m[2]] = (int)$m[1];
      }
    }
    $allAutoStart = file($autostart, FILE_IGNORE_NEW_LINES);
    if (is_array($allAutoStart)) {
      $sort = [];
      foreach ($allAutoStart as $ct) {
        $ctName = explode(' ', $ct)[0];
        $sort[] = $nameToIdx[$ctName] ?? 999;
      }
      array_multisort($sort, SORT_NUMERIC, $allAutoStart);
      @file_put_contents($autostart, implode(PHP_EOL, $allAutoStart) . PHP_EOL);
    }
  }

  $raw = userprefs_order_sorted($path);
  $filtered = [];
  foreach ($raw as $name) {
    if ($name === '' || str_starts_with($name, 'folder-')) continue;
    $filtered[] = $name;
  }
  $same = implode('|', $filtered) === implode('|', $normalized);

  json_out([
    'ok' => true,
    'verify' => [
      'path' => $path,
      'mtime' => @filemtime($path),
      'same' => $same,
    ],
  ]);
}

if ($action === 'state') {
  $containerNames = docker_container_names();
  $running = docker_running_set();
  $icons = template_icon_map();
  $userPrefsPath = dockerMan_user_prefs_path();
  $defaultIcon = '/plugins/dynamix.docker.manager/images/question.png';

  $containers = [];
  foreach ($containerNames as $name) {
    $icon = $icons[$name] ?? '';
    $normalizedIcon = normalize_icon_url($icon);
    $stateIcon = dockerMan_state_icon_url($name);
    $containers[] = [
      'name' => $name,
      'running' => isset($running[$name]),
      'icon' => $stateIcon !== '' ? $stateIcon : ($normalizedIcon !== '' ? $normalizedIcon : $defaultIcon),
    ];
  }

  $order = order_from_dockerMan_user_prefs($containerNames);
  $settings = load_settings();
  json_out([
    'containers' => $containers,
    'order' => $order,
    'settings' => $settings,
    'meta' => [
      'orderSource' => 'dockerMan user-prefs',
      'userPrefsPath' => $userPrefsPath,
      'userPrefsMtime' => is_file($userPrefsPath) ? @filemtime($userPrefsPath) : null,
    ],
  ]);
}

if ($action === 'settings') {
  $body = read_request_body();
  $columns = isset($body['columns']) ? (int)$body['columns'] : 8;
  $columns = max(6, min(15, $columns));
  $ok = save_settings(['columns' => $columns]);
  if (!$ok) json_out(['ok' => false, 'error' => 'save_failed'], 500);
  json_out(['ok' => true, 'columns' => $columns]);
}

if ($action === 'backup') {
  $body = read_request_body();
  $order = $body['order'] ?? null;
  if (!is_array($order)) json_out(['ok' => false, 'error' => 'invalid_order'], 400);
  $order = array_values(array_map('strval', $order));
  $ok = write_latest_backup($order);
  if (!$ok) json_out(['ok' => false, 'error' => 'write_failed'], 500);
  json_out(['ok' => true]);
}

if ($action === 'latestBackup') {
  $backup = read_latest_backup();
  $order = $backup['order'] ?? [];
  json_out([
    'ok' => true,
    'ts' => $backup['ts'] ?? null,
    'order' => is_array($order) ? $order : [],
  ]);
}

json_out(['ok' => false, 'error' => 'unknown_action'], 404);
]]></INLINE>
</FILE>

<!-- Remove script -->
<FILE Run="/bin/bash" Method="remove">
<INLINE>
rm -rf "&emhttp;"
rm -rf "&plugin;"
</INLINE>
</FILE>

</PLUGIN>
